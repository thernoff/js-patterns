<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Шаблоны проектирования</title>
</head>

<body>
  <script>
    /*
      Единственный объект (Singleton)

      Суть шаблона единственного объекта состоит в том, чтобы обеспечить возможность создать только один экземпляр определенного класса. 
      Это означает, что при попытке создать второй экземпляр того же класса вызывающая программа должна получить объект, созданный при первой попытке.

      Когда объект создается с использованием литерала объекта, фактически создается единственный объект, и для этого не требуется использовать какие-либо 
      специальные синтаксические конструкции.

      Использование оператора new

      Идея заключается в том, чтобы при создании нескольких объектов с помощью оператора new и одного и того же конструктора вы получали бы просто новые ссылки на один 
      и тот же объект.
      var uni = new Universe();
      var uni2 = new Universe();
      uni === uni2; // true

      Экземпляр в статическом свойстве
      Это достаточно простое решение, обладающее единственным недостатком – свойство instance является общедоступным. 
      Маловероятно, что какой-то другой программный код изменит это свойство по ошибке (гораздо менее вероятно, чем в случае, если бы экземпляр
      сохранялся в глобальной переменной), тем не менее такая возможность существует.
    */
    function Universe() {
      // имеется ли экземпляр, созданный ранее?
      if (typeof Universe.instance === "object") {
        return Universe.instance;
      }

      // создать новый экземпляр
      this.start_time = 0;
      this.bang = "Big";

      // Сохранить его
      Universe.instance = this;

      // возврат экземпляра
      return this;
    }

    // проверка
    var uni = new Universe();
    var uni2 = new Universe();
    console.log(uni === uni2);

    /*
      Экземпляр в замыкании
      Другой способ реализовать шаб лон единственного экземпляра заключается в использовании замыкания для ограничения доступа к экземпляру. 
      Это можно реализовать с помощью шаб лона частных статических членов, обсуждавшегося в главе 5. 
      Секрет состоит в том, чтобы переопределить конструктор.
      При первом обращении вызывается оригинальный конструктор, возвращающий ссылку this как обычно. При втором, третьем и так далее обращении вызывается 
      уже переопределенный конструктор. Новый конструктор обладает доступом к частной переменной instance благодаря замыканию и просто возвращает ее.
    */
    function UniverseClosure() {
      // сохраненный экземпляр
      var instance = this;

      // создать новый экземпляр
      this.start_time = 0;
      this.bang = "Big";

      // переопределить конструктор
      UniverseClosure = function () {
        return instance;
      }
    }

    // проверка
    //var uniC = new UniverseClosure();
    //var uniC2 = new UniverseClosure();
    //console.log(uniC === uniC2);

    /*
      Недостаток этого шаблона, как уже обсуждалось ранее, состоит в том, что при переопределении функции (в данном случае конструктора Universe()) 
      она теряет все свойства, которые могли быть добавлены между моментом ее определения и моментом переопределения. В данном конкретном случае все, 
      что будет добавлено в прототип функции Universe(), окажется недоступно экземпляру, созданному оригинальной реализацией.
    */

    UniverseClosure.prototype.nothing = true;

    // получаем объект, у которого свойство [[Prototype]] является прототипом функции-конструктора UniverseClosure и содержит в себе свойство constructor,
    // ссылающеся на первоначальную функцию UniverseClosure,
    // но после первого вызова UniverseClosure, она будет переопределена и прототип уже у UniverseClosure будет другой
    var uniC = new UniverseClosure();
    // добавить еще одно свойство в прототип уже после создания первого объекта, 
    // при этом нужно понимать, что функция-конструктор UniverseClosure была переопределена
    UniverseClosure.prototype.everything = true;

    var uniC2 = new UniverseClosure();

    // проверка
    // объект имеет доступ только к оригинальному прототипу
    console.log(uniC.nothing); // true
    console.log(uniC2.nothing); // true
    console.log(uniC.everything); // undefined
    console.log(uniC2.everything); // undefined

    // это выражение дает ожидаемый результат
    console.log(uniC.constructor.name); // UniverseClosure
    // а это нет, т.к. uniC.constructor указывает на оригинальный конструктор, а не на переопределенный
    console.log(uniC.constructor === UniverseClosure); // false
  </script>
</body>

</html>