<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Шаблоны повторного использования программного кода</title>
</head>

<body>
  <script>
    /*
      Ожидаемый результат при использовании классического наследования
      Цель реализации классического наследования в том, чтобы объекты, создаваемые одной функцией-конструктором Child(),
      приобретали свойства, присущие другому конструктору Parent().
      Пример реализации конструкторов:
      // родительский конструктор
      function Parent(name) {
        this.name = name || 'Adam';
      }

      // добавление дополнительной функциональности в прототип
      Parent.prototype.say = function() {
        return this.name;
      }

      // пустой дочерний конструктор
      function Child(name) {}

      // наследование (функция inherit устанавливает зависимость наследования, ее нужно написать самостоятельно)
      inherit(Child, Parent)
    */

    // Классический шаблон №1: шаблон по умолчанию
    // Свойство prototype должно ссылаться на объект, а не на функцию!
    function inherit(C, P) {
      C.prototype = new P();
    }

    function Parent(name) {
      this.name = name || 'Adam';
    }

    Parent.prototype.say = function () {
      return this.name;
    }

    function Child(name) { }

    inherit(Child, Parent);

    var kid = new Child();
    console.log(kid.say()); // Adam

    var kid2 = new Child();
    // в данном случае мы создаем свойство name у объекта kid2
    kid2.name = 'Patrick';
    console.log(kid2.say()); // Patrick

    /*
      Недостатки шаблона №1
      Одним из недостатков является то обстоятельство, что дочерние объекты наследуют не только свойства прототипа родительского объекта,
      но и собственные свойства, добавленные к нему. В большинстве случаев наследовать собственные свойства нежелательно, потому что
      чаще всего они характерны для конкретного экземпляра и не могут повторно использоваться дочерними объектами.
      ! Главное правило при использовании констукторов - повторно используемые члены должны добавляться в прототип.

      Еще один недостаток заключается в том, что использование универсальной функции inherit() не позволяет передать параметры, 
      полученные при вызове дочерним конструктором, от дочернего конструктора родительскому.
    */
    var s = new Child('Seth');
    console.log(s.say()); // Adam
  </script>
</body>

</html>