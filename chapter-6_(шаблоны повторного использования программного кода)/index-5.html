<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Шаблоны повторного использования программного кода</title>
</head>

<body>
  <script>
    /*
      Классический шаблон №5: временный конструктор
      Следующий шаблон решает проблему, возникающую при совместном использовании прототипа, разрывая прямую связь между 
      родительским и дочерним прототипами, но сохраняя при этом преимущества, которые дает наличие цепочки прототипов.

      Ниже приводится реализация этого шаблона, где мы вводим пустую функцию F(), играющую роль передаточного звена между предком и потомком. 
      Свойство prototype функции F() ссылается на родительский прототип. А прототипом потомка является экземпляр пустой функции:
      
      function inherit(C, P) {
        var F = function() {}
        F.prototype = P.prototype;
        C.prototype = new F();
      }
    */

    function inherit(C, P) {
      var F = function () { };
      F.prototype = P.prototype;
      C.prototype = new F();
    }

    function Parent(name) {
      this.name = name || 'Adam';
    }

    Parent.prototype.say = function () {
      return this.name;
    }

    function Child(name) { }

    inherit(Child, Parent);

    var kid = new Child();
    // свойство name из родительского объекта не наследуется, т.к. является собственным
    // свойством родительского объекта
    console.log(kid.say()); // undefined


    /*
      Сохранение суперкласса
      Предыдущий шаблон можно несколько расширить, добавив в него ссылку на оригинального предка. Это напоминает доступ к суперклассу
      в других языках и может оказаться полезным в некоторых ситуациях. Назовем это свойство uber, потому что слово «super» является зарезервированным словом, 
      а слово «superclass» может натолкнуть непосвященного разработчика на мысль, что в Java Script есть классы. 
      Ниже приводится улучшенная реализация этого классического шаблона:

      function inherit(C, P) {
        // создаем функциональное выражение
        var F = function() {}

        // в качестве прототипа функции F устанавливаем ссылку на прототип функции P
        F.prototype = P.prototype;

        // в качестве прототипа функции C (Child) устанавливаем объект, возвращенный функцией-конструктором F, 
        // у данного объекта при создании свойство [[Prototype]] будет ссылаться на прототип функции-конструктора, а это по сути прототип функции P,
        // НО при этом C.prototype != P.prototype, т.к. C.prototype.__proto__ === P.prototype
        C.prototype = new F();

        // сохраняем ссылку на родительский прототип
        C.uber = P.prototype;
      }
    */


    /*
      Установка указателя на конструктор
      Если не переустановить указатель на конструктор, все дочерние объекты будут полагать, что их конструктором является Parent(), который не
      особо полезен. То есть, используя предыдущую реализацию функции inherit(), можно наблюдать следующее поведение объектов:
    */
    console.log(kid);
    console.log(kid.constructor.name);
    console.log(kid.constructor === Parent);

  </script>
</body>

</html>